#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(deref_nullptr)]

/* automatically generated by rust-bindgen 0.59.2 */

pub const EXIF_TAG_GPS_VERSION_ID: u32 = 0;
pub const EXIF_TAG_GPS_LATITUDE_REF: u32 = 1;
pub const EXIF_TAG_GPS_LATITUDE: u32 = 2;
pub const EXIF_TAG_GPS_LONGITUDE_REF: u32 = 3;
pub const EXIF_TAG_GPS_LONGITUDE: u32 = 4;
pub const EXIF_TAG_GPS_ALTITUDE_REF: u32 = 5;
pub const EXIF_TAG_GPS_ALTITUDE: u32 = 6;
pub const EXIF_TAG_GPS_TIME_STAMP: u32 = 7;
pub const EXIF_TAG_GPS_SATELLITES: u32 = 8;
pub const EXIF_TAG_GPS_STATUS: u32 = 9;
pub const EXIF_TAG_GPS_MEASURE_MODE: u32 = 10;
pub const EXIF_TAG_GPS_DOP: u32 = 11;
pub const EXIF_TAG_GPS_SPEED_REF: u32 = 12;
pub const EXIF_TAG_GPS_SPEED: u32 = 13;
pub const EXIF_TAG_GPS_TRACK_REF: u32 = 14;
pub const EXIF_TAG_GPS_TRACK: u32 = 15;
pub const EXIF_TAG_GPS_IMG_DIRECTION_REF: u32 = 16;
pub const EXIF_TAG_GPS_IMG_DIRECTION: u32 = 17;
pub const EXIF_TAG_GPS_MAP_DATUM: u32 = 18;
pub const EXIF_TAG_GPS_DEST_LATITUDE_REF: u32 = 19;
pub const EXIF_TAG_GPS_DEST_LATITUDE: u32 = 20;
pub const EXIF_TAG_GPS_DEST_LONGITUDE_REF: u32 = 21;
pub const EXIF_TAG_GPS_DEST_LONGITUDE: u32 = 22;
pub const EXIF_TAG_GPS_DEST_BEARING_REF: u32 = 23;
pub const EXIF_TAG_GPS_DEST_BEARING: u32 = 24;
pub const EXIF_TAG_GPS_DEST_DISTANCE_REF: u32 = 25;
pub const EXIF_TAG_GPS_DEST_DISTANCE: u32 = 26;
pub const EXIF_TAG_GPS_PROCESSING_METHOD: u32 = 27;
pub const EXIF_TAG_GPS_AREA_INFORMATION: u32 = 28;
pub const EXIF_TAG_GPS_DATE_STAMP: u32 = 29;
pub const EXIF_TAG_GPS_DIFFERENTIAL: u32 = 30;
pub const EXIF_TAG_GPS_H_POSITIONING_ERROR: u32 = 31;
pub const ExifByteOrder_EXIF_BYTE_ORDER_MOTOROLA: ExifByteOrder = 0;
pub const ExifByteOrder_EXIF_BYTE_ORDER_INTEL: ExifByteOrder = 1;
pub type ExifByteOrder = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_byte_order_get_name(order: ExifByteOrder) -> *const ::std::os::raw::c_char;
}
pub const ExifDataType_EXIF_DATA_TYPE_UNCOMPRESSED_CHUNKY: ExifDataType = 0;
pub const ExifDataType_EXIF_DATA_TYPE_UNCOMPRESSED_PLANAR: ExifDataType = 1;
pub const ExifDataType_EXIF_DATA_TYPE_UNCOMPRESSED_YCC: ExifDataType = 2;
pub const ExifDataType_EXIF_DATA_TYPE_COMPRESSED: ExifDataType = 3;
pub const ExifDataType_EXIF_DATA_TYPE_COUNT: ExifDataType = 4;
pub const ExifDataType_EXIF_DATA_TYPE_UNKNOWN: ExifDataType = 4;
pub type ExifDataType = ::std::os::raw::c_uint;
pub const ExifIfd_EXIF_IFD_0: ExifIfd = 0;
pub const ExifIfd_EXIF_IFD_1: ExifIfd = 1;
pub const ExifIfd_EXIF_IFD_EXIF: ExifIfd = 2;
pub const ExifIfd_EXIF_IFD_GPS: ExifIfd = 3;
pub const ExifIfd_EXIF_IFD_INTEROPERABILITY: ExifIfd = 4;
pub const ExifIfd_EXIF_IFD_COUNT: ExifIfd = 5;
pub type ExifIfd = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_ifd_get_name(ifd: ExifIfd) -> *const ::std::os::raw::c_char;
}
pub const ExifFormat_EXIF_FORMAT_BYTE: ExifFormat = 1;
pub const ExifFormat_EXIF_FORMAT_ASCII: ExifFormat = 2;
pub const ExifFormat_EXIF_FORMAT_SHORT: ExifFormat = 3;
pub const ExifFormat_EXIF_FORMAT_LONG: ExifFormat = 4;
pub const ExifFormat_EXIF_FORMAT_RATIONAL: ExifFormat = 5;
pub const ExifFormat_EXIF_FORMAT_SBYTE: ExifFormat = 6;
pub const ExifFormat_EXIF_FORMAT_UNDEFINED: ExifFormat = 7;
pub const ExifFormat_EXIF_FORMAT_SSHORT: ExifFormat = 8;
pub const ExifFormat_EXIF_FORMAT_SLONG: ExifFormat = 9;
pub const ExifFormat_EXIF_FORMAT_SRATIONAL: ExifFormat = 10;
pub const ExifFormat_EXIF_FORMAT_FLOAT: ExifFormat = 11;
pub const ExifFormat_EXIF_FORMAT_DOUBLE: ExifFormat = 12;
pub type ExifFormat = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_format_get_name(format: ExifFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_format_get_size(format: ExifFormat) -> ::std::os::raw::c_uchar;
}
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type ExifByte = ::std::os::raw::c_uchar;
pub type ExifSByte = ::std::os::raw::c_schar;
pub type ExifAscii = *mut ::std::os::raw::c_char;
pub type ExifShort = u16;
pub type ExifSShort = i16;
pub type ExifLong = u32;
pub type ExifSLong = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExifRational {
    pub numerator: ExifLong,
    pub denominator: ExifLong,
}
#[test]
fn bindgen_test_layout_ExifRational() {
    assert_eq!(
        ::std::mem::size_of::<ExifRational>(),
        8usize,
        concat!("Size of: ", stringify!(ExifRational))
    );
    assert_eq!(
        ::std::mem::align_of::<ExifRational>(),
        4usize,
        concat!("Alignment of ", stringify!(ExifRational))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExifRational>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExifRational),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExifRational>())).denominator as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ExifRational),
            "::",
            stringify!(denominator)
        )
    );
}
pub type ExifUndefined = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExifSRational {
    pub numerator: ExifSLong,
    pub denominator: ExifSLong,
}
#[test]
fn bindgen_test_layout_ExifSRational() {
    assert_eq!(
        ::std::mem::size_of::<ExifSRational>(),
        8usize,
        concat!("Size of: ", stringify!(ExifSRational))
    );
    assert_eq!(
        ::std::mem::align_of::<ExifSRational>(),
        4usize,
        concat!("Alignment of ", stringify!(ExifSRational))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExifSRational>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExifSRational),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExifSRational>())).denominator as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ExifSRational),
            "::",
            stringify!(denominator)
        )
    );
}
extern "C" {
    pub fn exif_get_short(b: *const ::std::os::raw::c_uchar, order: ExifByteOrder) -> ExifShort;
}
extern "C" {
    pub fn exif_get_sshort(b: *const ::std::os::raw::c_uchar, order: ExifByteOrder) -> ExifSShort;
}
extern "C" {
    pub fn exif_get_long(b: *const ::std::os::raw::c_uchar, order: ExifByteOrder) -> ExifLong;
}
extern "C" {
    pub fn exif_get_slong(b: *const ::std::os::raw::c_uchar, order: ExifByteOrder) -> ExifSLong;
}
extern "C" {
    pub fn exif_get_rational(
        b: *const ::std::os::raw::c_uchar,
        order: ExifByteOrder,
    ) -> ExifRational;
}
extern "C" {
    pub fn exif_get_srational(
        b: *const ::std::os::raw::c_uchar,
        order: ExifByteOrder,
    ) -> ExifSRational;
}
extern "C" {
    pub fn exif_set_short(b: *mut ::std::os::raw::c_uchar, order: ExifByteOrder, value: ExifShort);
}
extern "C" {
    pub fn exif_set_sshort(
        b: *mut ::std::os::raw::c_uchar,
        order: ExifByteOrder,
        value: ExifSShort,
    );
}
extern "C" {
    pub fn exif_set_long(b: *mut ::std::os::raw::c_uchar, order: ExifByteOrder, value: ExifLong);
}
extern "C" {
    pub fn exif_set_slong(b: *mut ::std::os::raw::c_uchar, order: ExifByteOrder, value: ExifSLong);
}
extern "C" {
    pub fn exif_set_rational(
        b: *mut ::std::os::raw::c_uchar,
        order: ExifByteOrder,
        value: ExifRational,
    );
}
extern "C" {
    pub fn exif_set_srational(
        b: *mut ::std::os::raw::c_uchar,
        order: ExifByteOrder,
        value: ExifSRational,
    );
}
extern "C" {
    pub fn exif_convert_utf16_to_utf8(
        out: *mut ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_uchar,
        maxlen: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exif_array_set_byte_order(
        arg1: ExifFormat,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_uint,
        o_orig: ExifByteOrder,
        o_new: ExifByteOrder,
    );
}
pub type ExifMemAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(s: ExifLong) -> *mut ::std::os::raw::c_void>;
pub type ExifMemReallocFunc = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut ::std::os::raw::c_void,
        s: ExifLong,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type ExifMemFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(p: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifMem {
    _unused: [u8; 0],
}
pub type ExifMem = _ExifMem;
extern "C" {
    pub fn exif_mem_new(
        a: ExifMemAllocFunc,
        r: ExifMemReallocFunc,
        f: ExifMemFreeFunc,
    ) -> *mut ExifMem;
}
extern "C" {
    pub fn exif_mem_ref(arg1: *mut ExifMem);
}
extern "C" {
    pub fn exif_mem_unref(arg1: *mut ExifMem);
}
extern "C" {
    pub fn exif_mem_alloc(m: *mut ExifMem, s: ExifLong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn exif_mem_realloc(
        m: *mut ExifMem,
        p: *mut ::std::os::raw::c_void,
        s: ExifLong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn exif_mem_free(m: *mut ExifMem, p: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn exif_mem_new_default() -> *mut ExifMem;
}
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifLog {
    _unused: [u8; 0],
}
pub type ExifLog = _ExifLog;
extern "C" {
    pub fn exif_log_new() -> *mut ExifLog;
}
extern "C" {
    pub fn exif_log_new_mem(arg1: *mut ExifMem) -> *mut ExifLog;
}
extern "C" {
    pub fn exif_log_ref(log: *mut ExifLog);
}
extern "C" {
    pub fn exif_log_unref(log: *mut ExifLog);
}
extern "C" {
    pub fn exif_log_free(log: *mut ExifLog);
}
pub const ExifLogCode_EXIF_LOG_CODE_NONE: ExifLogCode = 0;
pub const ExifLogCode_EXIF_LOG_CODE_DEBUG: ExifLogCode = 1;
pub const ExifLogCode_EXIF_LOG_CODE_NO_MEMORY: ExifLogCode = 2;
pub const ExifLogCode_EXIF_LOG_CODE_CORRUPT_DATA: ExifLogCode = 3;
pub type ExifLogCode = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_log_code_get_title(code: ExifLogCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_log_code_get_message(code: ExifLogCode) -> *const ::std::os::raw::c_char;
}
pub type ExifLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log: *mut ExifLog,
        arg1: ExifLogCode,
        domain: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn exif_log_set_func(
        log: *mut ExifLog,
        func: ExifLogFunc,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn exif_log(
        log: *mut ExifLog,
        arg1: ExifLogCode,
        domain: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn exif_logv(
        log: *mut ExifLog,
        arg1: ExifLogCode,
        domain: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
pub const ExifTag_EXIF_TAG_INTEROPERABILITY_INDEX: ExifTag = 1;
pub const ExifTag_EXIF_TAG_INTEROPERABILITY_VERSION: ExifTag = 2;
pub const ExifTag_EXIF_TAG_NEW_SUBFILE_TYPE: ExifTag = 254;
pub const ExifTag_EXIF_TAG_IMAGE_WIDTH: ExifTag = 256;
pub const ExifTag_EXIF_TAG_IMAGE_LENGTH: ExifTag = 257;
pub const ExifTag_EXIF_TAG_BITS_PER_SAMPLE: ExifTag = 258;
pub const ExifTag_EXIF_TAG_COMPRESSION: ExifTag = 259;
pub const ExifTag_EXIF_TAG_PHOTOMETRIC_INTERPRETATION: ExifTag = 262;
pub const ExifTag_EXIF_TAG_FILL_ORDER: ExifTag = 266;
pub const ExifTag_EXIF_TAG_DOCUMENT_NAME: ExifTag = 269;
pub const ExifTag_EXIF_TAG_IMAGE_DESCRIPTION: ExifTag = 270;
pub const ExifTag_EXIF_TAG_MAKE: ExifTag = 271;
pub const ExifTag_EXIF_TAG_MODEL: ExifTag = 272;
pub const ExifTag_EXIF_TAG_STRIP_OFFSETS: ExifTag = 273;
pub const ExifTag_EXIF_TAG_ORIENTATION: ExifTag = 274;
pub const ExifTag_EXIF_TAG_SAMPLES_PER_PIXEL: ExifTag = 277;
pub const ExifTag_EXIF_TAG_ROWS_PER_STRIP: ExifTag = 278;
pub const ExifTag_EXIF_TAG_STRIP_BYTE_COUNTS: ExifTag = 279;
pub const ExifTag_EXIF_TAG_X_RESOLUTION: ExifTag = 282;
pub const ExifTag_EXIF_TAG_Y_RESOLUTION: ExifTag = 283;
pub const ExifTag_EXIF_TAG_PLANAR_CONFIGURATION: ExifTag = 284;
pub const ExifTag_EXIF_TAG_RESOLUTION_UNIT: ExifTag = 296;
pub const ExifTag_EXIF_TAG_TRANSFER_FUNCTION: ExifTag = 301;
pub const ExifTag_EXIF_TAG_SOFTWARE: ExifTag = 305;
pub const ExifTag_EXIF_TAG_DATE_TIME: ExifTag = 306;
pub const ExifTag_EXIF_TAG_ARTIST: ExifTag = 315;
pub const ExifTag_EXIF_TAG_WHITE_POINT: ExifTag = 318;
pub const ExifTag_EXIF_TAG_PRIMARY_CHROMATICITIES: ExifTag = 319;
pub const ExifTag_EXIF_TAG_SUB_IFDS: ExifTag = 330;
pub const ExifTag_EXIF_TAG_TRANSFER_RANGE: ExifTag = 342;
pub const ExifTag_EXIF_TAG_JPEG_PROC: ExifTag = 512;
pub const ExifTag_EXIF_TAG_JPEG_INTERCHANGE_FORMAT: ExifTag = 513;
pub const ExifTag_EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH: ExifTag = 514;
pub const ExifTag_EXIF_TAG_YCBCR_COEFFICIENTS: ExifTag = 529;
pub const ExifTag_EXIF_TAG_YCBCR_SUB_SAMPLING: ExifTag = 530;
pub const ExifTag_EXIF_TAG_YCBCR_POSITIONING: ExifTag = 531;
pub const ExifTag_EXIF_TAG_REFERENCE_BLACK_WHITE: ExifTag = 532;
pub const ExifTag_EXIF_TAG_XML_PACKET: ExifTag = 700;
pub const ExifTag_EXIF_TAG_RELATED_IMAGE_FILE_FORMAT: ExifTag = 4096;
pub const ExifTag_EXIF_TAG_RELATED_IMAGE_WIDTH: ExifTag = 4097;
pub const ExifTag_EXIF_TAG_RELATED_IMAGE_LENGTH: ExifTag = 4098;
pub const ExifTag_EXIF_TAG_IMAGE_DEPTH: ExifTag = 32997;
pub const ExifTag_EXIF_TAG_CFA_REPEAT_PATTERN_DIM: ExifTag = 33421;
pub const ExifTag_EXIF_TAG_CFA_PATTERN: ExifTag = 33422;
pub const ExifTag_EXIF_TAG_BATTERY_LEVEL: ExifTag = 33423;
pub const ExifTag_EXIF_TAG_COPYRIGHT: ExifTag = 33432;
pub const ExifTag_EXIF_TAG_EXPOSURE_TIME: ExifTag = 33434;
pub const ExifTag_EXIF_TAG_FNUMBER: ExifTag = 33437;
pub const ExifTag_EXIF_TAG_IPTC_NAA: ExifTag = 33723;
pub const ExifTag_EXIF_TAG_IMAGE_RESOURCES: ExifTag = 34377;
pub const ExifTag_EXIF_TAG_EXIF_IFD_POINTER: ExifTag = 34665;
pub const ExifTag_EXIF_TAG_INTER_COLOR_PROFILE: ExifTag = 34675;
pub const ExifTag_EXIF_TAG_EXPOSURE_PROGRAM: ExifTag = 34850;
pub const ExifTag_EXIF_TAG_SPECTRAL_SENSITIVITY: ExifTag = 34852;
pub const ExifTag_EXIF_TAG_GPS_INFO_IFD_POINTER: ExifTag = 34853;
pub const ExifTag_EXIF_TAG_ISO_SPEED_RATINGS: ExifTag = 34855;
pub const ExifTag_EXIF_TAG_OECF: ExifTag = 34856;
pub const ExifTag_EXIF_TAG_TIME_ZONE_OFFSET: ExifTag = 34858;
pub const ExifTag_EXIF_TAG_SENSITIVITY_TYPE: ExifTag = 34864;
pub const ExifTag_EXIF_TAG_STANDARD_OUTPUT_SENSITIVITY: ExifTag = 34865;
pub const ExifTag_EXIF_TAG_RECOMMENDED_EXPOSURE_INDEX: ExifTag = 34866;
pub const ExifTag_EXIF_TAG_ISO_SPEED: ExifTag = 34867;
pub const ExifTag_EXIF_TAG_ISO_SPEEDLatitudeYYY: ExifTag = 34868;
pub const ExifTag_EXIF_TAG_ISO_SPEEDLatitudeZZZ: ExifTag = 34869;
pub const ExifTag_EXIF_TAG_EXIF_VERSION: ExifTag = 36864;
pub const ExifTag_EXIF_TAG_DATE_TIME_ORIGINAL: ExifTag = 36867;
pub const ExifTag_EXIF_TAG_DATE_TIME_DIGITIZED: ExifTag = 36868;
pub const ExifTag_EXIF_TAG_OFFSET_TIME: ExifTag = 36880;
pub const ExifTag_EXIF_TAG_OFFSET_TIME_ORIGINAL: ExifTag = 36881;
pub const ExifTag_EXIF_TAG_OFFSET_TIME_DIGITIZED: ExifTag = 36882;
pub const ExifTag_EXIF_TAG_COMPONENTS_CONFIGURATION: ExifTag = 37121;
pub const ExifTag_EXIF_TAG_COMPRESSED_BITS_PER_PIXEL: ExifTag = 37122;
pub const ExifTag_EXIF_TAG_SHUTTER_SPEED_VALUE: ExifTag = 37377;
pub const ExifTag_EXIF_TAG_APERTURE_VALUE: ExifTag = 37378;
pub const ExifTag_EXIF_TAG_BRIGHTNESS_VALUE: ExifTag = 37379;
pub const ExifTag_EXIF_TAG_EXPOSURE_BIAS_VALUE: ExifTag = 37380;
pub const ExifTag_EXIF_TAG_MAX_APERTURE_VALUE: ExifTag = 37381;
pub const ExifTag_EXIF_TAG_SUBJECT_DISTANCE: ExifTag = 37382;
pub const ExifTag_EXIF_TAG_METERING_MODE: ExifTag = 37383;
pub const ExifTag_EXIF_TAG_LIGHT_SOURCE: ExifTag = 37384;
pub const ExifTag_EXIF_TAG_FLASH: ExifTag = 37385;
pub const ExifTag_EXIF_TAG_FOCAL_LENGTH: ExifTag = 37386;
pub const ExifTag_EXIF_TAG_SUBJECT_AREA: ExifTag = 37396;
pub const ExifTag_EXIF_TAG_TIFF_EP_STANDARD_ID: ExifTag = 37398;
pub const ExifTag_EXIF_TAG_MAKER_NOTE: ExifTag = 37500;
pub const ExifTag_EXIF_TAG_USER_COMMENT: ExifTag = 37510;
pub const ExifTag_EXIF_TAG_SUB_SEC_TIME: ExifTag = 37520;
pub const ExifTag_EXIF_TAG_SUB_SEC_TIME_ORIGINAL: ExifTag = 37521;
pub const ExifTag_EXIF_TAG_SUB_SEC_TIME_DIGITIZED: ExifTag = 37522;
pub const ExifTag_EXIF_TAG_XP_TITLE: ExifTag = 40091;
pub const ExifTag_EXIF_TAG_XP_COMMENT: ExifTag = 40092;
pub const ExifTag_EXIF_TAG_XP_AUTHOR: ExifTag = 40093;
pub const ExifTag_EXIF_TAG_XP_KEYWORDS: ExifTag = 40094;
pub const ExifTag_EXIF_TAG_XP_SUBJECT: ExifTag = 40095;
pub const ExifTag_EXIF_TAG_FLASH_PIX_VERSION: ExifTag = 40960;
pub const ExifTag_EXIF_TAG_COLOR_SPACE: ExifTag = 40961;
pub const ExifTag_EXIF_TAG_PIXEL_X_DIMENSION: ExifTag = 40962;
pub const ExifTag_EXIF_TAG_PIXEL_Y_DIMENSION: ExifTag = 40963;
pub const ExifTag_EXIF_TAG_RELATED_SOUND_FILE: ExifTag = 40964;
pub const ExifTag_EXIF_TAG_INTEROPERABILITY_IFD_POINTER: ExifTag = 40965;
pub const ExifTag_EXIF_TAG_FLASH_ENERGY: ExifTag = 41483;
pub const ExifTag_EXIF_TAG_SPATIAL_FREQUENCY_RESPONSE: ExifTag = 41484;
pub const ExifTag_EXIF_TAG_FOCAL_PLANE_X_RESOLUTION: ExifTag = 41486;
pub const ExifTag_EXIF_TAG_FOCAL_PLANE_Y_RESOLUTION: ExifTag = 41487;
pub const ExifTag_EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT: ExifTag = 41488;
pub const ExifTag_EXIF_TAG_SUBJECT_LOCATION: ExifTag = 41492;
pub const ExifTag_EXIF_TAG_EXPOSURE_INDEX: ExifTag = 41493;
pub const ExifTag_EXIF_TAG_SENSING_METHOD: ExifTag = 41495;
pub const ExifTag_EXIF_TAG_FILE_SOURCE: ExifTag = 41728;
pub const ExifTag_EXIF_TAG_SCENE_TYPE: ExifTag = 41729;
pub const ExifTag_EXIF_TAG_NEW_CFA_PATTERN: ExifTag = 41730;
pub const ExifTag_EXIF_TAG_CUSTOM_RENDERED: ExifTag = 41985;
pub const ExifTag_EXIF_TAG_EXPOSURE_MODE: ExifTag = 41986;
pub const ExifTag_EXIF_TAG_WHITE_BALANCE: ExifTag = 41987;
pub const ExifTag_EXIF_TAG_DIGITAL_ZOOM_RATIO: ExifTag = 41988;
pub const ExifTag_EXIF_TAG_FOCAL_LENGTH_IN_35MM_FILM: ExifTag = 41989;
pub const ExifTag_EXIF_TAG_SCENE_CAPTURE_TYPE: ExifTag = 41990;
pub const ExifTag_EXIF_TAG_GAIN_CONTROL: ExifTag = 41991;
pub const ExifTag_EXIF_TAG_CONTRAST: ExifTag = 41992;
pub const ExifTag_EXIF_TAG_SATURATION: ExifTag = 41993;
pub const ExifTag_EXIF_TAG_SHARPNESS: ExifTag = 41994;
pub const ExifTag_EXIF_TAG_DEVICE_SETTING_DESCRIPTION: ExifTag = 41995;
pub const ExifTag_EXIF_TAG_SUBJECT_DISTANCE_RANGE: ExifTag = 41996;
pub const ExifTag_EXIF_TAG_IMAGE_UNIQUE_ID: ExifTag = 42016;
pub const ExifTag_EXIF_TAG_CAMERA_OWNER_NAME: ExifTag = 42032;
pub const ExifTag_EXIF_TAG_BODY_SERIAL_NUMBER: ExifTag = 42033;
pub const ExifTag_EXIF_TAG_LENS_SPECIFICATION: ExifTag = 42034;
pub const ExifTag_EXIF_TAG_LENS_MAKE: ExifTag = 42035;
pub const ExifTag_EXIF_TAG_LENS_MODEL: ExifTag = 42036;
pub const ExifTag_EXIF_TAG_LENS_SERIAL_NUMBER: ExifTag = 42037;
pub const ExifTag_EXIF_TAG_COMPOSITE_IMAGE: ExifTag = 42080;
pub const ExifTag_EXIF_TAG_SOURCE_IMAGE_NUMBER_OF_COMPOSITE_IMAGE: ExifTag = 42081;
pub const ExifTag_EXIF_TAG_SOURCE_EXPOSURE_TIMES_OF_COMPOSITE_IMAGE: ExifTag = 42082;
pub const ExifTag_EXIF_TAG_GAMMA: ExifTag = 42240;
pub const ExifTag_EXIF_TAG_PRINT_IMAGE_MATCHING: ExifTag = 50341;
pub const ExifTag_EXIF_TAG_PADDING: ExifTag = 59932;
pub type ExifTag = ::std::os::raw::c_uint;
pub const ExifSupportLevel_EXIF_SUPPORT_LEVEL_UNKNOWN: ExifSupportLevel = 0;
pub const ExifSupportLevel_EXIF_SUPPORT_LEVEL_NOT_RECORDED: ExifSupportLevel = 1;
pub const ExifSupportLevel_EXIF_SUPPORT_LEVEL_MANDATORY: ExifSupportLevel = 2;
pub const ExifSupportLevel_EXIF_SUPPORT_LEVEL_OPTIONAL: ExifSupportLevel = 3;
pub type ExifSupportLevel = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_tag_from_name(name: *const ::std::os::raw::c_char) -> ExifTag;
}
extern "C" {
    pub fn exif_tag_get_name_in_ifd(tag: ExifTag, ifd: ExifIfd) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_title_in_ifd(tag: ExifTag, ifd: ExifIfd) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_description_in_ifd(
        tag: ExifTag,
        ifd: ExifIfd,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_support_level_in_ifd(
        tag: ExifTag,
        ifd: ExifIfd,
        t: ExifDataType,
    ) -> ExifSupportLevel;
}
extern "C" {
    pub fn exif_tag_get_name(tag: ExifTag) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_title(tag: ExifTag) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_description(tag: ExifTag) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_table_get_tag(n: ::std::os::raw::c_uint) -> ExifTag;
}
extern "C" {
    pub fn exif_tag_table_get_name(n: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_table_count() -> ::std::os::raw::c_uint;
}
#[doc = " Represents the entire EXIF data found in an image"]
pub type ExifData = _ExifData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifDataPrivate {
    _unused: [u8; 0],
}
pub type ExifDataPrivate = _ExifDataPrivate;
pub type ExifContent = _ExifContent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifContentPrivate {
    _unused: [u8; 0],
}
pub type ExifContentPrivate = _ExifContentPrivate;
pub type ExifEntry = _ExifEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifEntryPrivate {
    _unused: [u8; 0],
}
pub type ExifEntryPrivate = _ExifEntryPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifEntry {
    pub tag: ExifTag,
    pub format: ExifFormat,
    pub components: ::std::os::raw::c_ulong,
    pub data: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_uint,
    pub parent: *mut ExifContent,
    pub priv_: *mut ExifEntryPrivate,
}
#[test]
fn bindgen_test_layout__ExifEntry() {
    assert_eq!(
        ::std::mem::size_of::<_ExifEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_ExifEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_ExifEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_ExifEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifEntry>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifEntry>())).format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifEntry>())).components as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifEntry>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifEntry>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifEntry>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifEntry>())).priv_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn exif_entry_new() -> *mut ExifEntry;
}
extern "C" {
    pub fn exif_entry_new_mem(arg1: *mut ExifMem) -> *mut ExifEntry;
}
extern "C" {
    pub fn exif_entry_ref(entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_entry_unref(entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_entry_free(entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_entry_initialize(e: *mut ExifEntry, tag: ExifTag);
}
extern "C" {
    pub fn exif_entry_fix(entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_entry_get_value(
        entry: *mut ExifEntry,
        val: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_entry_dump(entry: *mut ExifEntry, indent: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifContent {
    pub entries: *mut *mut ExifEntry,
    pub count: ::std::os::raw::c_uint,
    pub parent: *mut ExifData,
    pub priv_: *mut ExifContentPrivate,
}
#[test]
fn bindgen_test_layout__ExifContent() {
    assert_eq!(
        ::std::mem::size_of::<_ExifContent>(),
        32usize,
        concat!("Size of: ", stringify!(_ExifContent))
    );
    assert_eq!(
        ::std::mem::align_of::<_ExifContent>(),
        8usize,
        concat!("Alignment of ", stringify!(_ExifContent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifContent>())).entries as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifContent),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifContent>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifContent),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifContent>())).parent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifContent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifContent>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifContent),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn exif_content_new() -> *mut ExifContent;
}
extern "C" {
    pub fn exif_content_new_mem(arg1: *mut ExifMem) -> *mut ExifContent;
}
extern "C" {
    pub fn exif_content_ref(content: *mut ExifContent);
}
extern "C" {
    pub fn exif_content_unref(content: *mut ExifContent);
}
extern "C" {
    pub fn exif_content_free(content: *mut ExifContent);
}
extern "C" {
    pub fn exif_content_add_entry(c: *mut ExifContent, entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_content_remove_entry(c: *mut ExifContent, e: *mut ExifEntry);
}
extern "C" {
    pub fn exif_content_get_entry(content: *mut ExifContent, tag: ExifTag) -> *mut ExifEntry;
}
extern "C" {
    pub fn exif_content_fix(c: *mut ExifContent);
}
pub type ExifContentForeachEntryFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ExifEntry, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn exif_content_foreach_entry(
        content: *mut ExifContent,
        func: ExifContentForeachEntryFunc,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn exif_content_get_ifd(c: *mut ExifContent) -> ExifIfd;
}
extern "C" {
    pub fn exif_content_dump(content: *mut ExifContent, indent: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn exif_content_log(content: *mut ExifContent, log: *mut ExifLog);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifMnoteData {
    _unused: [u8; 0],
}
pub type ExifMnoteData = _ExifMnoteData;
extern "C" {
    pub fn exif_mnote_data_ref(arg1: *mut ExifMnoteData);
}
extern "C" {
    pub fn exif_mnote_data_unref(arg1: *mut ExifMnoteData);
}
extern "C" {
    pub fn exif_mnote_data_load(
        d: *mut ExifMnoteData,
        buf: *const ::std::os::raw::c_uchar,
        buf_size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn exif_mnote_data_save(
        d: *mut ExifMnoteData,
        buf: *mut *mut ::std::os::raw::c_uchar,
        buf_size: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn exif_mnote_data_count(d: *mut ExifMnoteData) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn exif_mnote_data_get_id(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn exif_mnote_data_get_name(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_mnote_data_get_title(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_mnote_data_get_description(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_mnote_data_get_value(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
        val: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_mnote_data_log(arg1: *mut ExifMnoteData, arg2: *mut ExifLog);
}
#[doc = " Represents the entire EXIF data found in an image"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifData {
    #[doc = " Data for each IFD"]
    pub ifd: [*mut ExifContent; 5usize],
    #[doc = " Pointer to thumbnail image, or NULL if not available"]
    pub data: *mut ::std::os::raw::c_uchar,
    #[doc = " Number of bytes in thumbnail image at \\c data"]
    pub size: ::std::os::raw::c_uint,
    pub priv_: *mut ExifDataPrivate,
}
#[test]
fn bindgen_test_layout__ExifData() {
    assert_eq!(
        ::std::mem::size_of::<_ExifData>(),
        64usize,
        concat!("Size of: ", stringify!(_ExifData))
    );
    assert_eq!(
        ::std::mem::align_of::<_ExifData>(),
        8usize,
        concat!("Alignment of ", stringify!(_ExifData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifData>())).ifd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifData),
            "::",
            stringify!(ifd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifData>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifData>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ExifData>())).priv_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifData),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[doc = " Allocate a new #ExifData. The #ExifData contains an empty"]
    #[doc = " #ExifContent for each IFD and the default set of options,"]
    #[doc = " which has #EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS"]
    #[doc = " and #EXIF_DATA_OPTION_FOLLOW_SPECIFICATION set."]
    #[doc = ""]
    #[doc = " \\return allocated #ExifData, or NULL on error"]
    pub fn exif_data_new() -> *mut ExifData;
}
extern "C" {
    #[doc = " Allocate a new #ExifData using the given memory allocator."]
    #[doc = " The #ExifData contains an empty #ExifContent for each IFD and the default"]
    #[doc = " set of options, which has #EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS and"]
    #[doc = " #EXIF_DATA_OPTION_FOLLOW_SPECIFICATION set."]
    #[doc = ""]
    #[doc = " \\return allocated #ExifData, or NULL on error"]
    pub fn exif_data_new_mem(arg1: *mut ExifMem) -> *mut ExifData;
}
extern "C" {
    #[doc = " Allocate a new #ExifData and load EXIF data from a JPEG file."]
    #[doc = " Uses an #ExifLoader internally to do the loading."]
    #[doc = ""]
    #[doc = " \\param[in] path filename including path"]
    #[doc = " \\return allocated #ExifData, or NULL on error"]
    pub fn exif_data_new_from_file(path: *const ::std::os::raw::c_char) -> *mut ExifData;
}
extern "C" {
    #[doc = " Allocate a new #ExifData and load EXIF data from a memory buffer."]
    #[doc = ""]
    #[doc = " \\param[in] data pointer to raw JPEG or EXIF data"]
    #[doc = " \\param[in] size number of bytes of data at data"]
    #[doc = " \\return allocated #ExifData, or NULL on error"]
    pub fn exif_data_new_from_data(
        data: *const ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_uint,
    ) -> *mut ExifData;
}
extern "C" {
    #[doc = " Load the #ExifData structure from the raw JPEG or EXIF data in the given"]
    #[doc = " memory buffer. If the EXIF data contains a recognized MakerNote, it is"]
    #[doc = " loaded and stored as well for later retrieval by #exif_data_get_mnote_data."]
    #[doc = " If the #EXIF_DATA_OPTION_FOLLOW_SPECIFICATION option has been set on this"]
    #[doc = " #ExifData, then the tags are automatically fixed after loading (by calling"]
    #[doc = " #exif_data_fix)."]
    #[doc = ""]
    #[doc = " \\param[in,out] data EXIF data"]
    #[doc = " \\param[in] d pointer to raw JPEG or EXIF data"]
    #[doc = " \\param[in] size number of bytes of data at d"]
    pub fn exif_data_load_data(
        data: *mut ExifData,
        d: *const ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Store raw EXIF data representing the #ExifData structure into a memory"]
    #[doc = " buffer. The buffer is allocated by this function and must subsequently be"]
    #[doc = " freed by the caller using the matching free function as used by the #ExifMem"]
    #[doc = " in use by this #ExifData."]
    #[doc = ""]
    #[doc = " \\param[in] data EXIF data"]
    #[doc = " \\param[out] d pointer to buffer pointer containing raw EXIF data on return"]
    #[doc = " \\param[out] ds pointer to variable to hold the number of bytes of"]
    #[doc = "   data at d, or set to 0 on error"]
    pub fn exif_data_save_data(
        data: *mut ExifData,
        d: *mut *mut ::std::os::raw::c_uchar,
        ds: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn exif_data_ref(data: *mut ExifData);
}
extern "C" {
    pub fn exif_data_unref(data: *mut ExifData);
}
extern "C" {
    pub fn exif_data_free(data: *mut ExifData);
}
extern "C" {
    #[doc = " Return the byte order in use by this EXIF structure."]
    #[doc = ""]
    #[doc = " \\param[in] data EXIF data"]
    #[doc = " \\return byte order"]
    pub fn exif_data_get_byte_order(data: *mut ExifData) -> ExifByteOrder;
}
extern "C" {
    #[doc = " Set the byte order to use for this EXIF data. If any tags already exist"]
    #[doc = " (including MakerNote tags) they are are converted to the specified byte"]
    #[doc = " order."]
    #[doc = ""]
    #[doc = " \\param[in,out] data EXIF data"]
    #[doc = " \\param[in] order byte order"]
    pub fn exif_data_set_byte_order(data: *mut ExifData, order: ExifByteOrder);
}
extern "C" {
    #[doc = " Return the MakerNote data out of the EXIF data.  Only certain"]
    #[doc = " MakerNote formats that are recognized by libexif are supported."]
    #[doc = " The pointer references a member of the #ExifData structure and must NOT be"]
    #[doc = " freed by the caller."]
    #[doc = ""]
    #[doc = " \\param[in] d EXIF data"]
    #[doc = " \\return MakerNote data, or NULL if not found or not supported"]
    pub fn exif_data_get_mnote_data(d: *mut ExifData) -> *mut ExifMnoteData;
}
extern "C" {
    #[doc = " Fix the EXIF data to bring it into specification. Call #exif_content_fix"]
    #[doc = " on each IFD to fix existing entries, create any new entries that are"]
    #[doc = " mandatory but do not yet exist, and remove any entries that are not"]
    #[doc = " allowed."]
    #[doc = ""]
    #[doc = " \\param[in,out] d EXIF data"]
    pub fn exif_data_fix(d: *mut ExifData);
}
pub type ExifDataForeachContentFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ExifContent, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Execute a function on each IFD in turn."]
    #[doc = ""]
    #[doc = " \\param[in] data EXIF data over which to iterate"]
    #[doc = " \\param[in] func function to call for each entry"]
    #[doc = " \\param[in] user_data data to pass into func on each call"]
    pub fn exif_data_foreach_content(
        data: *mut ExifData,
        func: ExifDataForeachContentFunc,
        user_data: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Act as though unknown tags are not present"]
pub const ExifDataOption_EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS: ExifDataOption = 1;
#[doc = " Fix the EXIF tags to follow the spec"]
pub const ExifDataOption_EXIF_DATA_OPTION_FOLLOW_SPECIFICATION: ExifDataOption = 2;
#[doc = " Leave the MakerNote alone, which could cause it to be corrupted"]
pub const ExifDataOption_EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE: ExifDataOption = 4;
#[doc = " Options to configure the behaviour of #ExifData"]
pub type ExifDataOption = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Return a short textual description of the given #ExifDataOption."]
    #[doc = ""]
    #[doc = " \\param[in] o option"]
    #[doc = " \\return localized textual description of the option,"]
    #[doc = "   or NULL if unknown"]
    pub fn exif_data_option_get_name(o: ExifDataOption) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a verbose textual description of the given #ExifDataOption."]
    #[doc = ""]
    #[doc = " \\param[in] o option"]
    #[doc = " \\return verbose localized textual description of the option,"]
    #[doc = "   or NULL if unknown"]
    pub fn exif_data_option_get_description(o: ExifDataOption) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the given option on the given #ExifData."]
    #[doc = ""]
    #[doc = " \\param[in] d EXIF data"]
    #[doc = " \\param[in] o option"]
    pub fn exif_data_set_option(d: *mut ExifData, o: ExifDataOption);
}
extern "C" {
    #[doc = " Clear the given option on the given #ExifData."]
    #[doc = ""]
    #[doc = " \\param[in] d EXIF data"]
    #[doc = " \\param[in] o option"]
    pub fn exif_data_unset_option(d: *mut ExifData, o: ExifDataOption);
}
extern "C" {
    #[doc = " Set the data type for the given #ExifData."]
    #[doc = ""]
    #[doc = " \\param[in] d EXIF data"]
    #[doc = " \\param[in] dt data type"]
    pub fn exif_data_set_data_type(d: *mut ExifData, dt: ExifDataType);
}
extern "C" {
    #[doc = " Return the data type for the given #ExifData."]
    #[doc = ""]
    #[doc = " \\param[in] d EXIF data"]
    #[doc = " \\return data type, or #EXIF_DATA_TYPE_UNKNOWN on error"]
    pub fn exif_data_get_data_type(d: *mut ExifData) -> ExifDataType;
}
extern "C" {
    #[doc = " Dump all EXIF data to stdout."]
    #[doc = " This is intended for diagnostic purposes only."]
    #[doc = ""]
    #[doc = " \\param[in] data EXIF data"]
    pub fn exif_data_dump(data: *mut ExifData);
}
extern "C" {
    #[doc = " Set the log message object for all IFDs."]
    #[doc = ""]
    #[doc = " \\param[in] data EXIF data"]
    #[doc = " \\param[in] log #ExifLog"]
    pub fn exif_data_log(data: *mut ExifData, log: *mut ExifLog);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
